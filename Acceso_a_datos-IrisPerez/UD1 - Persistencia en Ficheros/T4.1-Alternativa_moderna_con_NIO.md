# (Gestión de Archivos con Path y Files)

**Descripción**  
Este subtema introduce el uso de la API `java.nio.file`, que representa una evolución moderna respecto a la clase `File`. Incluye las clases `Path`, `Files`, y `Paths`, que permiten una gestión más clara, robusta y multiplataforma de archivos y rutas.

## Introducción

Java NIO (New Input/Output) es una API introducida en Java 7 que mejora significativamente el rendimiento y la flexibilidad en las operaciones de entrada/salida. A diferencia de `java.io`, que se basa en flujos secuenciales, `java.nio` se apoya en conceptos como **canales**, **búferes** y **selectores**, ofreciendo una forma más potente de manejar datos.

Desde Java 7 se recomienda usar el paquete `java.nio.file` para el manejo de archivos. Las clases más utilizadas son:

- `Path`: representa una ruta de archivo o directorio.
    
- `Paths`: clase utilitaria para obtener objetos `Path`.
    
- `Files`: contiene métodos estáticos para trabajar con archivos y directorios (leer, escribir, mover, borrar, copiar, etc).
    

Este enfoque permite trabajar de forma más segura y eficiente, con soporte para codificaciones como UTF-8, operaciones atómicas, y uso con streams de Java 8.

## ¿Por qué usar Java NIO?

- **Mayor rendimiento**: gracias a la lectura/escritura mediante búferes y operaciones por bloques.
    
- **Operaciones no bloqueantes**: permite continuar ejecutando otras tareas mientras se completan las operaciones de E/S.
    
- **Soporte para aplicaciones de red**: ideal para servidores y clientes concurrentes.
    
- **Capacidad para manejar grandes volúmenes de datos**.

## Conceptos clave en Java NIO

### Canales (`Channel`)

Un canal representa una conexión con una entidad de E/S, como un archivo, un socket o un dispositivo. Se puede leer y escribir datos en el canal de forma más directa que con los streams tradicionales.

Ejemplo: `FileChannel`, `SocketChannel`, `DatagramChannel`.

### Búferes (`Buffer`)

Los búferes son bloques de memoria que permiten almacenar datos de entrada o salida temporalmente. Cada canal está vinculado a un búfer, el cual facilita operaciones por bloques en lugar de byte a byte.

Ejemplo: `ByteBuffer`, `CharBuffer`, `IntBuffer`.

### Selectores (`Selector`)

Permiten supervisar múltiples canales de forma no bloqueante. Son especialmente útiles en aplicaciones de red (como servidores) donde se deben gestionar múltiples conexiones simultáneamente con eficiencia.

## ¿Cuándo utilizar Java NIO?

- Aplicaciones de red multicliente (chat, servidores web).
    
- Manipulación de archivos de gran tamaño.
    
- Aplicaciones de alto rendimiento: trading, juegos, procesadores de datos.
    
- Operaciones asíncronas o concurrentes de E/S.

## Ejemplo básico: uso de Path y Files

```java
import java.nio.file.*;

public class CrearArchivoNIO {
    public static void main(String[] args) {
        try {
            Path ruta = Paths.get("datos/archivo_nio.txt");

            if (!Files.exists(ruta)) {
                Files.createDirectories(ruta.getParent());
                Files.createFile(ruta);
                System.out.println("Archivo creado.");
            } else {
                System.out.println("El archivo ya existe.");
            }

            System.out.println("Nombre: " + ruta.getFileName());
            System.out.println("Ruta absoluta: " + ruta.toAbsolutePath());
        } catch (Exception e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}
```
>![[ejecucion_CrearArchivoNIO.png]]

## Ejemplo: lectura y escritura con Files y UTF-8

```java
import java.nio.file.*;
import java.util.List;
import java.nio.charset.StandardCharsets;
import java.io.IOException;

public class LecturaEscrituraNIO {
    public static void main(String[] args) {
        Path ruta = Paths.get("datos/nio_contenido.txt");

        try {
            List<String> lineas = List.of("Línea A", "Línea B", "Línea C");
            Files.write(ruta, lineas, StandardCharsets.UTF_8);
            System.out.println("Contenido escrito.");

            List<String> leidas = Files.readAllLines(ruta, StandardCharsets.UTF_8);
            System.out.println("Contenido leído:");
            for (String linea : leidas) {
                System.out.println("> " + linea);
            }
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}
```

> ![[ejecucion_LecturaEscrituraNIO.png]]

## Ejemplo con canal y búfer

```java
import java.nio.file.*;
import java.nio.channels.SeekableByteChannel;
import java.nio.ByteBuffer;
import java.io.IOException;

public class NIOExample {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("miArchivo.txt");

        try (SeekableByteChannel channel = Files.newByteChannel(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE)) {
            byte[] data = "Hola, mundo!".getBytes();
            ByteBuffer buffer = ByteBuffer.wrap(data);
            channel.write(buffer);
        }
    }
}
```

> ![[ejecucion_NIOExample.png]]

## Ventajas de NIO sobre File

|Característica|`File`|`Path` + `Files` (`NIO`)|
|---|---|---|
|Manejo de rutas|Limitado|Muy flexible, multiplataforma|
|Crear archivos|`.createNewFile()`|`Files.createFile(path)`|
|Leer/escribir todo|No nativo|`Files.readAllLines`, `write`|
|UTF-8 por defecto|No|Sí (con charset configurable)|
|Streams|No|Sí (`Files.lines()`, `Files.walk()`)|
|Seguridad|Menos chequeos|Más validaciones|

## Resumen

Java NIO es una evolución importante del modelo clásico de E/S. Ofrece operaciones más potentes, asíncronas y eficientes, siendo ideal para escenarios donde el rendimiento o la concurrencia son factores clave. Su curva de aprendizaje es mayor, pero sus ventajas lo hacen recomendable para aplicaciones modernas.


> [!Extra] La clase `Scanner` en Java
> [[Extra-La_clase_Scanner_en_Java]]
